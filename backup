#!/bin/bash
PATH=/bin:/usr/bin
if [ ! -d "$BACKUP_EXECUTABLE_DIR" ]; then
	BACKUP_EXECUTABLE_DIR=${0%/*}
fi
source $BACKUP_EXECUTABLE_DIR/library.sh || exit 1
source $BACKUP_EXECUTABLE_DIR/load-settings.sh || exit 1

function check_and_lock {
	if [ "$SESSION" ]; then
		# Already locked, so continue
		return 0;
	fi
	if [ -e "$SESSION_DIR/lock" ]; then
		error "Backup process at `cat $SESSION_DIR/lock` appears to be running; delete $SESSION_DIR/lock to unlock."
	fi
	export SESSION=true
	mkdir -p $SESSION_DIR
	trap "rm -rf '$SESSION_DIR'" EXIT
	echo $$ >$SESSION_DIR/lock
	cat >$SESSION_DIR/settings <<EOF
DRY_RUN=$DRY_RUN
VERBOSE=$VERBOSE
EOF
}

function parse_command {
	cmd=$1
	case "$cmd" in 
		-n|--dry-run)
			shift
			DRY_RUN=true
			parse_command $*;;
		-v|--verbose)
			shift
			VERBOSE=true
			parse_command $*;;
		-e|--edit)
			shift
			if [ -n "$1" ]; then
				$EDITOR "$PROFILES/$*"
			else
				$EDITOR $REPOS
			fi ;;
		-lock|--lock)
			echo "All backups are locked; delete $SESSION_DIR/lock to unlock." 1>&2
			trap '' EXIT
			exit ;;
		--log)
			cat $LOG
			exit ;;
		-l|--list)
			shift
			for profile in `find $PROFILES -maxdepth 1`; do
				if [ ! -n "$root" ]; then
					root=`echo $profile | wc -m`
				else
					echo ${profile:$root}
				fi
			done  ;;
		*)
			check_and_lock
			$BACKUP_EXECUTABLE_DIR/run_profile $*
			;;
	esac;
}
parse_command $*
